# Software_eng_lab4

# بازآرایی کد (Code Refactoring)

---

## روال انجام آزمایش
در این آزمایش قرار است یک پروژه را با هدف افزایش خوانایی و کارایی آن از طریق تغییر در ساختار برنامه بدون اینکه رفتار خارجی آن تغییر کند، بازآزایی کنیم. در ابتدا برنامه را اجرا کرده و خروجی آن را ذخیره می‌کنیم و بعد از هر مرحله بازآرایی، دوباره از برنامه خروجی می‌گیریم تا مطمئن شویم که با اعمال این تغییرات، رفتار خارجی برنامه تغییری نکرده باشد. حال بازآرایی‌های خواسته شده را یک به یک اعمال می‌کنیم:

### اعمال الگوی Facade:
این الگو، کلاسی است که یک رابط ساده برای یک زیرسیستم پیچیده که شامل قطعات بسیاریست فراهم می‌کند. یک facade ممکن است عملکرد محدودی را در مقایسه با کار مستقیم با زیرسیستم ارائه دهد. با این حال قطعا شامل ویژگی‌هایی خواهد بود که کلاینت به آن‌ها اهمیت داده و استفاده می‌کند.
#### ۱) مورد اول، `CodeGenerator`:
در `Parser` می‌توان دید که زیرسیستم `CodeGenerator` به طور مستقیم استفاده می‌شود تا از توابع آن استفاده کند. برای کاهش پیچیدگی، یک کلاس `CodeGeneratorFacade` می‌سازیم و تنها توابعی که کلاینت قرار است از آن‌ها استفاده کند را در آن قرار می‌دهیم و در آن توابع، توابع اصلی‌ای که در خود کلاس `CodeGenerator` هستند را صدا می‌زنیم. این تغییر را می‌توانید در زیر مشاهده کنید:

<img width="979" alt="Screenshot 1402-05-21 at 2 57 44 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/90343a83-ea71-433b-a9d9-fd1575e31c25">
<img width="1201" alt="Screenshot 1402-05-21 at 3 04 06 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/df08e1d1-d3bf-49b1-849f-b0145dbc2d81">


#### ۲) مورد دوم، `Memory`:
در این مورد هم مانند مورد قبلی، `SymbolTable` به طور مستقیم از `Memory` استفاده می‌کند. پس یک `MemoryFacade` می‌سازیم و تغییرات مورد نیاز را اعمال می‌کنیم:

<img width="811" alt="Screenshot 1402-05-21 at 3 06 39 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/ce50c6de-08c1-4850-95b6-595349d421a8">
<img width="1317" alt="Screenshot 1402-05-21 at 3 06 57 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/0dd91dd9-56b2-4ac9-90ad-323cfa43e3ca">
<img width="1319" alt="Screenshot 1402-05-21 at 3 07 45 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/69c40094-4863-49b6-8fc0-7de15805defe">

### ۳) اعمال الگوی استفاده از Polymorphism به جای شرط:
طیق این الگو، شرط‌های `switch-case‍` را بازآرایی کرده و جای آن، کلاس‌های فرعی جدیدی می‌سازیم که هر یک متناظر با یکی از caseها باشند. برای مثال در کد اولیه، یک `enum` با عنوان `TypeAddress` داریم که در کلاس `Address` و حین اجرای `toString`، روی انواع آن `switch-case‍` زده شده، پس هر یک را به یک کلاس جدید تبدیل می‌کنیم:

<img width="1317" alt="Screenshot 1402-05-21 at 3 17 10 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/12ec8239-6856-4e8d-a6eb-abd87f33bd2f">
<img width="1317" alt="Screenshot 1402-05-21 at 3 17 25 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/e8e8910c-adcd-48ff-90c0-1d3d3f679591">
<img width="1316" alt="Screenshot 1402-05-21 at 3 17 34 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/47fd008c-f686-41c2-888b-134933f809cb">
<img width="1318" alt="Screenshot 1402-05-21 at 3 17 44 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/a1646525-81d1-498f-b9ae-e574b79ac350">
<img width="1410" alt="Screenshot 1402-05-21 at 3 18 39 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/25090aee-3eb5-4553-98df-cb7f39a0de15">
<img width="1410" alt="Screenshot 1402-05-21 at 3 18 51 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/5bef959b-b8e7-418d-aca5-1e3e1484872b">
<img width="1412" alt="Screenshot 1402-05-21 at 3 19 02 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/e0c5c12e-7f60-41db-b91c-21364f152fe3">

### ۴) اعمال الگوی Separate Query From Modifier:
این الگو، CQRS را پیاده سازی می‌کند. این اصل به ما می‌گوید که کدهای مسئول دریافت داده‌ها را از کدهایی که چیزی را در داخل یک شی تغییر می‌دهند جدا کنیم. برای مثال این مورد در `SymbolTable` در تابع ‍`getNextParameter` وجود داشت که به شکل زیر آن را بازآرایی کردیم:

<img width="1406" alt="Screenshot 1402-05-21 at 3 24 58 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/79e5a295-ed5f-4fe9-a293-3fcefbfc1790">
<img width="1409" alt="Screenshot 1402-05-21 at 3 25 09 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/4aaadd0c-f381-4b4c-ab32-66b6515568c5">

### ۵) اعمال الگوی Self Encapsulate Field:
این الگو مربوط به مواردیست که در توابع یک کلاس، به طور مستقیم از متغیرهای خصوصی آن استفاده می‌شود. گاهی اوقات این دسترسی مستقیم در داخل یک کلاس به اندازه کافی انعطاف پذیر نیست. برای مثال در `lexicalAnalyzer` دسترسی مستقیم به متغیر خصوصی `matcher` وجود داشت که آن را به شکل زیر تغییر دادیم:

<img width="1408" alt="Screenshot 1402-05-21 at 3 33 00 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/a0663a09-115d-481c-93d8-a0416bacc247">

### ۶) اعمال الگوی Separate Query From Modifier، دومین مورد:
توضیحات این بازآرایی در بالا آمده است. در `Memory` و تابع `getDataAddress` نیز مشکل دریافت داده و تغییر همزمان آن دیده می‌شود. بنابراین آن را به شکل زیر تغییر می‌دهیم. باید دقت شود که از آن‌جا که برای `Memory` یک `'Facade` ساخته بودیم، تغییرات را در آن نیز باید اعمال کنیم:

<img width="1269" alt="Screenshot 1402-05-21 at 3 38 50 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/b3c68c83-dbf5-4d76-8b21-76b3cca499a0">
<img width="1270" alt="Screenshot 1402-05-21 at 3 39 00 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/f7541e42-4d2e-4fdb-a94a-d9b53ca58f9a">
<img width="1412" alt="Screenshot 1402-05-21 at 3 39 23 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/d0473422-a742-4163-b145-4a5a1257aa81">

### ۷) اعمال الگوی inline temp:
وقتی یک متغیر موقت داریم که نتیجه‌ی یک عبارت ساده به آن اختصاص داده می‌شود و هیچ کارایی بیش‌تری ندارد، می‌توانیم ارجاعات متغیر را با خود عبارت جایگزین کنیم. این مورد در `Token` و تابع `hashCode` دیده می‌شد که آن را به شکل زیر تغییر دادیم:

<img width="1409" alt="Screenshot 1402-05-21 at 3 45 25 PM" src="https://github.com/karanehk/software_eng_lab4/assets/59361911/a011721e-4f69-47e5-a9b8-dcb959c78b2d">

---

## پرسش‌ها

1. هر یک از مفاهیم زیر را در حد یک خط توضیح دهید.
    - کد تمیز: کد تمیز به کدهای برنامه نویسی‌ای اشاره دارد که ساختار مناسب و تمیزی دارند، به راحتی قابل درکند و نگه‌داری از آن‌ها آسان است. این کدها از قراردادها و بهترین شیوه‌ها (best practices) پیروی می‌کنند. کد تمیز بر سادگی، خوانایی و حداقل پیچیدگی، افزایش همکاری و کاهش خطاها در توسعه نرم‌افزار تاکید دارد. 
    - بدهی فنی: بدهی فنی در برنامه نویسی مانند استفاده از میانبرها یا استفاده از راه حل‌های سریع هنگام نوشتن کد است که می‌تواند در کوتاه مدت، کارها را سریع‌تر کند اما منجر به افزایش پیچیدگی، مشکلات نگهداری و کاهش کارایی در درازمدت می شود. این مورد مانند قرض گرفتن زمان از آینده برای اتمام سریع کاری در حال حاضر است، اما باید بعداً با صرف زمان بیشتر برای اصلاح یا بهبود کد، آن را بازپرداخت کنیم.
    - بوی بد: بوی بد در برنامه نویسی به بخشی از کد اشاره دارد که درست به نظر نمی‌رسد. ممکن است یک باگ نباشد، اما نشانه‌ی آن است که کد می تواند بهبود یابد. درست مانند اینکه بوی بد در زندگی واقعی به ما می‌گوید چیزی مشکل دارد، بوی بد در کد نشان می‌دهد که راه بهتری برای نوشتن آن برای وضوح، کارایی یا قابلیت نگهداری وجود دارد. مثال‌های آن، کدهای با ساختاری ضعیف، کدهای تکراری و یا ناکارآمد، که نگهداری و اشکال‌زدابیشان دشوارتر است، می‌باشند.
---

2. طبق دسته‌بندی وب‌سایت refactoring.guru، بوهای بد کد به پنج دسته تقسیم می‌شوند. در مورد هر کدام از این پنج دسته توضیح مختصری دهید.
    - دسته‌ی اول، bloaters است که کدهای بسیار بزرگ یا پیچیده هستند که می‌توانند ساده شوند. bloaters درک، نگهداری و اصلاح کد را سخت تر می‌کنند. مثال‌ها شامل روش‌ها یا کلاس‌های طولانی است که بیش از حد کارهای مختلف انجام می‌دهند، یا ساختارهای داده‌ای که به‌طور غیرضروری بزرگ شده‌اند.
    - دسته‌ی دوم، Object-Orientation Abusers است که زمانی رخ می دهد که اصول شی گرا به درستی رعایت نشود و منجر به کدهایی می شود که از مزایای برنامه نویسی شی گرا به طور کامل استفاده نمی کند. مشکلات رایج آن عبارتند از استفاده نامناسب از وراثت، کلاس هایی با مسئولیت های بیش از حد، یا متدهایی که باید در یک کلاس متفاوت باشند.
    - دسته‌ی سوم، Change Preventers است که تغییر یا گسترش کد را در هنگام تغییر نیازها دشوار می‌کند. آنها اغلب ناشی از وابستگی های فشرده، ساختارهای سفت و سخت یا انتزاع ضعیف هستند. به عنوان مثال می توان به مقادیر hard-coded، فقدان رابط‌های مناسب، یا اجزای محکم‌جفت‌شده اشاره کرد. 
    - دسته‌ی چهارم، Dispensables است که به قسمت‌هایی از کد اشاره می‌کنند که می توان بدون تأثیرگذاری بر عملکرد، با خیال راحت حذف شوند. آنها باعث پیچیدگی غیر ضروری می‌شوند و می‌توانند توسعه دهندگان را گیج کنند. به عنوان مثال می توان به کدهای کامنت شده، متغیرهای استفاده نشده یا کدهای مرده اشاره کرد که هرگز اجرا نمی شوند.
    - دسته‌ی پنجم، Couplers است که نشان‌دهنده ارتباط بیش از حد بین بخش‌های مختلف کد است که تغییر یک قسمت را بدون تأثیر بر روی قسمت‌های دیگر دشوار می‌کند. اتصال محکم انعطاف پذیری را کاهش می دهد و کد را شکننده تر می کند. به عنوان مثال می توان به کلاس هایی اشاره کرد که به شدت به یکدیگر متکی هستند یا پارامترهای زیادی را بین توابع ارسال می کنند.

---

3.  یکی از انواع بوهای بد، Lazy Class است.
    - این بوی بد در کدام یک از دسته‌بندی‌های پنج‌گانه قرار می‌گیرد؟ یک lazy class معمولاً در زمینه بوی کد تحت دسته Dispensables قرار می گیرد. کلاس تنبل به کلاسی اطلاق می‌شود که value  زیادی به پایگاه کد مبادله نمی‌کند و می‌توان با خیال راحت بدون تأثیر بر عملکرد یا طراحی کلی سیستم، آن را حذف کرد. حذف چنین کلاس هایی می تواند وضوح کد را بهبود بخشد و پیچیدگی غیر ضروری را کاهش دهد.
    - برای برطرف‌کردن این بو، استفاده از کدام بازآرایی‌ها پیشنهاد می‌شود؟ راه اول، Remove Unused Code است. اگر کلاس تنبل حاوی متدها یا فیلدهای استفاده نشده باشد، حذف آنها باعث کاهش شلوغی می شود. راه دوم، Merge Classes است. اگر چندین کلاس کوچک با حداقل عملکرد وجود داشته باشد، ادغام آنها می تواند پایگاه کد را ساده کند. راه سوم، Inline Class است. اگر کلاس تنبل رفتار قابل توجهی ارائه نمی دهد و متدهای آن را می توان به راحتی به جای دیگری منتقل کرد، آن را inline می‌کنیم.
    - در چه مواقعی باید این بو را نادیده گرفت؟
می‌توان زمانی که lazy class برای توسعه آینده، سازگاری خارجی، ارائه اسناد یا برای اهداف debugging موقت مورد نیاز است، آن را نادیده بگیریم.

---




